#!/bin/sh
# The purpose of this script is to generate make targets for the Hare standard
# library. If you are adding new modules to the standard library, write a
# function for that module (e.g. encoding_utf8), and call the following helper
# commands:
#
# gen_srcs module::name list.ha of.ha sources.ha
# gen_ssa module::name list of module::names yours depends on
#
# Then add your module to the list of modules at the bottom.
#
# Then run ./gen-stdlib > mk/stdlib.mk to generate new rules.

srcdir="$(dirname "$0")"
eval ". $srcdir/mk/gen-stdlib.sh"

gensrcs_rt() {
	gen_srcs rt \
		'$(PLATFORM)/env.ha' \
		'$(PLATFORM)/errno.ha' \
		'$(PLATFORM)/segmalloc.ha' \
		'$(PLATFORM)/start.ha' \
		'$(PLATFORM)/stat.ha' \
		'$(PLATFORM)/$(ARCH).ha' \
		'$(PLATFORM)/syscallno$(ARCH).ha' \
		'$(PLATFORM)/syscalls.ha' \
		'$(PLATFORM)/types.ha' \
		'$(ARCH)/jmp.ha' \
		ensure.ha \
		jmp.ha \
		malloc.ha \
		memcpy.ha \
		memset.ha \
		strcmp.ha \
		$*
}

rt() {
	# This one is complicated, don't use it as a reference for other modules
	printf '# rt\n'
	if [ $testing -eq 0 ]
	then
		printf '%s\n' 'rtscript=$(STDLIB)/rt/hare.sc'
		gensrcs_rt \
			'$(PLATFORM)/abort.ha' \
			start.ha
	else
		gensrcs_rt \
			+test/abort.ha \
			+test/start.ha \
			+test/ztos.ha
	fi
	gen_ssa rt
	cat <<EOF
\$($cache)/rt/start.o: \$(STDLIB)/rt/\$(PLATFORM)/start\$(ARCH).s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@as -o \$@ \$<

${stdlib}_asm=\$($cache)/rt/syscall.o \\
	\$($cache)/rt/setjmp.o \\
	\$($cache)/rt/longjmp.o

\$($cache)/rt/syscall.o: \$(STDLIB)/rt/\$(PLATFORM)/syscall\$(ARCH).s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@as -o \$@ \$<

\$($cache)/rt/setjmp.o: \$(STDLIB)/rt/\$(ARCH)/setjmp.s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@as -o \$@ \$<

\$($cache)/rt/longjmp.o: \$(STDLIB)/rt/\$(ARCH)/longjmp.s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@as -o \$@ \$<

\$($cache)/rt/rt.a: \$($cache)/rt/rt.o \$(${stdlib}_asm)
	@printf 'AR\t\$@\n'
	@\$(AR) -csr \$@ \$($cache)/rt/rt.o \$(${stdlib}_asm)

${stdlib}_rt=\$($cache)/rt/rt.a
${stdlib}_start=\$($cache)/rt/start.o
hare_${stdlib}_deps+=\$(${stdlib}_rt)

EOF
}

ascii() {
	printf '# ascii\n'
	gen_srcs ascii \
		ctype.ha
	gen_ssa ascii
}

bufio() {
	printf '# bufio\n'
	gen_srcs bufio \
		fixed.ha
	gen_ssa bufio io rt
}

bytes() {
	printf '# bytes\n'
	gen_srcs bytes \
		contains.ha \
		copy.ha \
		equal.ha \
		index.ha \
		reverse.ha \
		tokenize.ha
	gen_ssa bytes
}

crypto_random() {
	printf '# crypto::random\n'
	gen_srcs crypto::random \
		'$(PLATFORM).ha' \
		random.ha
	gen_ssa crypto::random rt io
}

encoding_utf8() {
	# XXX: Also has ordering issues
	printf '# encoding::utf8\n'
	gen_srcs encoding::utf8 \
		rune.ha \
		decode.ha \
		encode.ha
	gen_ssa encoding::utf8 types
}

fmt() {
	printf '# fmt\n'
	gen_srcs fmt \
		fmt.ha
	gen_ssa fmt io os strconv strings types
}

hare_lex() {
	printf '# hare::lex\n'
	gen_srcs hare::lex \
		token.ha \
		lex.ha
	gen_ssa hare::lex bufio io strings types fmt
}

gensrcs_io() {
	gen_srcs io \
		'arch$(ARCH).ha' \
		types.ha \
		copy.ha \
		println.ha \
		stream.ha \
		limit.ha \
		strings.ha \
		$*
}

io() {
	# XXX: Sort me only after fixing forward references to alias types
	# Sort it to see what the problem is if you don't understand
	printf '# io\n'
	if [ $testing -eq 0 ]
	then
		gensrcs_io
	else
		if [ "$(uname -m)" = "aarch64" ]
		then
			# Test is broken on aarch64, temporarily disabled
			# https://todo.sr.ht/~sircmpwn/hare-v2/196
			gensrcs_io
		else
			gensrcs_io \
				+test/copy.ha \
				+test/limit.ha \
				+test/stream.ha \
				+test/strings.ha
		fi
	fi
	gen_ssa io strings
}

os() {
	printf '# os\n'
	gen_srcs os \
		'$(PLATFORM)/environ.ha' \
		'$(PLATFORM)/errors.ha' \
		'$(PLATFORM)/exit.ha' \
		'$(PLATFORM)/fdstream.ha' \
		'$(PLATFORM)/open.ha' \
		'$(PLATFORM)/stdfd.ha' \
		stdfd.ha
	gen_ssa os io strings types
}

os_exec() {
	printf '# os::exec\n'
	gen_srcs os::exec \
		'$(PLATFORM).ha' \
		cmd.ha
	gen_ssa os::exec os strings
}

gensrcs_strconv() {
	gen_srcs strconv \
		types.ha \
		itos.ha \
		utos.ha \
		stou.ha \
		stoi.ha \
		numeric.ha \
		$*
}

strconv() {
	printf '# strconv\n'
	if [ $testing -eq 0 ]
	then
		gensrcs_strconv
	else
		gensrcs_strconv \
			+test/stou.ha \
			+test/stoi.ha
	fi
	gen_ssa strconv types strings ascii
}

strings() {
	printf '# strings\n'
	gen_srcs strings \
		concat.ha \
		contains.ha \
		cstrings.ha \
		dup.ha \
		iter.ha \
		sub.ha \
		suffix.ha \
		tokenize.ha \
		utf8.ha
	gen_ssa strings encoding::utf8 types
}

types() {
	printf '# types\n'
	gen_srcs types \
		limits.ha \
		classes.ha \
		'arch$(ARCH).ha'
	gen_ssa types
}

printf '# This file is generated by the gen-stdlib script, do not edit it by hand\n\n'

modules="ascii
bufio
bytes
crypto_random
encoding_utf8
fmt
hare_lex
io
os
os_exec
strconv
strings
types"
stdlib() {
	rt
	for module in $modules; do
		gen_lib "$(printf "%s" "$module" | tr -s '_' '::')"
	done
	for module in $modules; do
		"$module"
	done
}

genrules
genrules test
