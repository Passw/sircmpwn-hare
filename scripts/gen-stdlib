#!/bin/sh
# The purpose of this script is to generate make targets for the Hare standard
# library. If you are adding new modules to the standard library, write a
# function for that module (e.g. encoding_utf8), and call the following helper
# commands:
#
# gen_srcs module::name list.ha of.ha sources.ha
# gen_ssa module::name list of module::names yours depends on
#
# Then add your module to the list of modules at the bottom.
#
# Then run ./scripts/gen-stdlib > stdlib.mk to generate new rules.

srcdir="$(dirname "$0")"
eval ". $srcdir/gen-stdlib.sh"

gensrcs_rt() {
	gen_srcs rt \
		'$(PLATFORM)/abort.ha' \
		'$(PLATFORM)/env.ha' \
		'$(PLATFORM)/errno.ha' \
		'$(PLATFORM)/types.ha' \
		'$(PLATFORM)/segmalloc.ha' \
		'$(PLATFORM)/platformstart.ha' \
		'$(PLATFORM)/$(ARCH).ha' \
		'$(PLATFORM)/syscallno$(ARCH).ha' \
		'$(PLATFORM)/syscalls.ha' \
		'$(PLATFORM)/signal.ha' \
		'$(PLATFORM)/stat.ha' \
		'$(PLATFORM)/socket.ha' \
		'$(ARCH)/jmp.ha' \
		ensure.ha \
		jmp.ha \
		malloc.ha \
		memcpy.ha \
		memset.ha \
		strcmp.ha \
		$*
}

rt() {
	# This one is complicated, don't use it as a reference for other modules
	if [ $testing -eq 0 ]
	then
		printf '%s\n' 'rtscript=$(STDLIB)/rt/hare.sc'
		gensrcs_rt \
			abort.ha \
			start.ha
	else
		gensrcs_rt \
			start+test.ha \
			abort+test.ha \
			'+test/$(PLATFORM).ha' \
			+test/cstring.ha \
			+test/run.ha \
			+test/ztos.ha
	fi
	gen_ssa rt
	cat <<EOF
\$($cache)/rt/start.o: \$(STDLIB)/rt/\$(PLATFORM)/start\$(ARCH).s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@\$(AS) -o \$@ \$<

${stdlib}_asm=\$($cache)/rt/syscall.o \\
	\$($cache)/rt/setjmp.o \\
	\$($cache)/rt/longjmp.o \\
	\$($cache)/rt/restore.o \\
	\$($cache)/rt/start.o

\$($cache)/rt/syscall.o: \$(STDLIB)/rt/\$(PLATFORM)/syscall\$(ARCH).s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@\$(AS) -o \$@ \$<

\$($cache)/rt/setjmp.o: \$(STDLIB)/rt/\$(ARCH)/setjmp.s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@\$(AS) -o \$@ \$<

\$($cache)/rt/longjmp.o: \$(STDLIB)/rt/\$(ARCH)/longjmp.s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@\$(AS) -o \$@ \$<

\$($cache)/rt/restore.o: \$(STDLIB)/rt/\$(ARCH)/restore.s
	@printf 'AS \t\$@\n'
	@mkdir -p \$($cache)/rt
	@\$(AS) -o \$@ \$<

\$($cache)/rt/rt.a: \$($cache)/rt/rt.o \$(${stdlib}_asm)
	@printf 'AR\t\$@\n'
	@\$(AR) -csr \$@ \$($cache)/rt/rt.o \$(${stdlib}_asm)

${stdlib}_rt=\$($cache)/rt/rt.a
hare_${stdlib}_deps+=\$(${stdlib}_rt)

EOF
}

ascii() {
	gen_srcs ascii \
		ctype.ha \
		strcmp.ha
	gen_ssa ascii strings
}

bufio() {
	gen_srcs bufio \
		buffered.ha \
		dynamic.ha \
		fixed.ha \
		scanner.ha
	gen_ssa bufio io bytes strings encoding::utf8 errors
}

bytes() {
	gen_srcs bytes \
		contains.ha \
		copy.ha \
		equal.ha \
		index.ha \
		reverse.ha \
		tokenize.ha
	gen_ssa bytes types
}

compress_flate() {
	gen_srcs compress::flate \
		inflate.ha
	gen_ssa compress::flate bufio bytes endian errors io fmt
}

compress_zlib() {
	if [ $testing -eq 0 ]
	then
		gen_srcs compress::zlib \
			reader.ha
	else
		gen_srcs compress::zlib \
			data+test.ha \
			reader.ha
	fi
	gen_ssa compress::zlib bufio bytes compress::flate endian errors hash \
		hash::adler32 io
}

crypto_math() {
	gen_srcs crypto::math \
		bits.ha
	gen_ssa crypto::math
}

crypto_random() {
	gen_srcs crypto::random \
		'$(PLATFORM).ha' \
		random.ha
	gen_ssa crypto::random rt io errors
}

gensrcs_crypto_sha256() {
	gen_srcs crypto::sha256 \
		sha256.ha \
		$*
}

genssa_crypto_sha256() {
	gen_ssa crypto::sha256 hash io endian $*
}

crypto_sha256() {
	if [ $testing -eq 0 ]
	then
		gensrcs_crypto_sha256
		genssa_crypto_sha256
	else
		gensrcs_crypto_sha256 \
			+test.ha
		genssa_crypto_sha256 fmt strio strings
	fi
}

crypto_sha1() {
	if [ $testing -eq 0 ]
	then
		gen_srcs crypto::sha1 sha1.ha
		gen_ssa crypto::sha1 hash io endian
	else
		gen_srcs crypto::sha1 sha1.ha +test.ha
		gen_ssa crypto::sha1 hash io endian fmt strio strings
	fi
}

crypto_sha512() {
	if [ $testing -eq 0 ]
	then
		gen_srcs crypto::sha512 sha512.ha
		gen_ssa crypto::sha512 hash io endian
	else
		gen_srcs crypto::sha512 sha512.ha +test.ha
		gen_ssa crypto::sha512 hash io endian fmt strio strings
	fi
}

crypto_md5() {
	if [ $testing -eq 0 ]
	then
		gen_srcs crypto::md5 md5.ha
		gen_ssa crypto::md5 hash io endian
	else
		gen_srcs crypto::md5 md5.ha +test.ha
		gen_ssa crypto::md5 hash io endian fmt strio strings
	fi
}

dirs() {
	gen_srcs dirs \
		xdg.ha
	gen_ssa dirs fs os path
}

encoding_hex() {
	gen_srcs encoding::hex \
		hex.ha
	gen_ssa encoding::hex ascii bytes fmt io strconv strio strings
}

encoding_utf8() {
	gen_srcs encoding::utf8 \
		decode.ha \
		encode.ha \
		rune.ha
	gen_ssa encoding::utf8 types
}

gensrcs_encoding_xml() {
	gen_srcs encoding::xml \
		types.ha \
		parser.ha \
		chars.ha \
		$*
}

encoding_xml() {
	if [ $testing -eq 0 ]
	then
		gensrcs_encoding_xml
	else
		gensrcs_encoding_xml +test.ha
	fi
	gen_ssa encoding::xml io bufio strings ascii strio
}

endian() {
	gen_srcs endian \
		big.ha \
		network.ha \
		little.ha \
		endian.ha \
		'host$(ARCH).ha'
	gen_ssa endian
}

errors() {
	gen_srcs errors \
		common.ha \
		docs.ha \
		opaque.ha \
		string.ha \
		rt.ha
	gen_ssa errors
}

fmt() {
	gen_srcs fmt \
		fmt.ha
	gen_ssa fmt bufio io os strconv strings types
}

format_elf() {
	gen_srcs format::elf \
		'$(ARCH).ha' \
		'$(PLATFORM).ha' \
		types.ha
	gen_ssa format::elf
}

fs() {
	gen_srcs fs \
		types.ha \
		fs.ha \
		util.ha
	gen_ssa fs io strings path time errors
}

getopt() {
	gen_srcs getopt \
		getopts.ha
	gen_ssa getopt encoding::utf8 fmt io os strings
}

hare_ast() {
	gen_srcs hare::ast \
		decl.ha \
		expr.ha \
		ident.ha \
		import.ha \
		type.ha \
		unit.ha
	gen_ssa hare::ast hare::lex
}

hare_unparse() {
	gen_srcs hare::unparse \
		expr.ha \
		decl.ha \
		ident.ha \
		import.ha \
		type.ha \
		unit.ha \
		util.ha
	gen_ssa hare::unparse fmt io strio hare::ast
}

gensrcs_hare_lex() {
	gen_srcs hare::lex \
		token.ha \
		lex.ha \
		$*
}

hare_lex() {
	if [ $testing -eq 0 ]
	then
		gensrcs_hare_lex
	else
		gensrcs_hare_lex \
			+test.ha
	fi
	gen_ssa hare::lex io bufio strings types fmt sort
}

hare_module() {
	gen_srcs hare::module \
		types.ha \
		context.ha \
		scan.ha \
		manifest.ha
	gen_ssa hare::module \
		hare::ast hare::lex hare::parse hare::unparse strio fs io strings hash \
		crypto::sha256 dirs bytes encoding::utf8 ascii fmt time slice bufio \
		strconv os encoding::hex sort errors
}

gensrcs_hare_parse() {
	gen_srcs hare::parse \
		decl.ha \
		expr.ha \
		exprclass.ha \
		ident.ha \
		import.ha \
		type.ha \
		types.ha \
		unit.ha \
		util.ha \
		$*
}

hare_parse() {
	if [ $testing -eq 0 ]
	then
		gensrcs_hare_parse
		gen_ssa hare::parse hare::ast hare::lex hare::unparse fmt
	else
		gensrcs_hare_parse \
			+test.ha
		gen_ssa hare::parse bufio fmt hare::ast hare::lex hare::unparse io \
			strings strio fmt
	fi
}

hash() {
	gen_srcs hash \
		hash.ha
	gen_ssa hash io
}

hash_adler32() {
	gen_srcs hash::adler32 \
		adler32.ha
	gen_ssa hash::adler32 endian hash io strings
}

hash_fnv() {
	gen_srcs hash::fnv \
		fnv.ha
	gen_ssa hash::fnv hash io strings
}

gensrcs_io() {
	gen_srcs io \
		'arch$(ARCH).ha' \
		copy.ha \
		limit.ha \
		println.ha \
		stream.ha \
		tee.ha \
		types.ha \
		$*
}

io() {
	if [ $testing -eq 0 ]
	then
		gensrcs_io
	else
		gensrcs_io \
			+test/copy.ha \
			+test/limit.ha \
			+test/stream.ha
	fi
	gen_ssa io strings errors
}

linux() {
	gen_srcs linux \
		start.ha \
		env.ha
	gen_ssa linux format::elf
}

linux_vdso() {
	gen_srcs linux::vdso \
		vdso.ha
	gen_ssa linux::vdso linux strings format::elf
}

net() {
	printf '# net\n'
	gen_srcs net \
		'$(PLATFORM)/socket.ha' \
		'$(PLATFORM)/util.ha' \
		socket.ha
	gen_ssa net io os strings net::ip net::unix errors
}

gensrcs_net_ip() {
	gen_srcs net::ip \
		ip.ha \
		'$(PLATFORM).ha' \
		$*
}

net_ip() {
	if [ $testing -eq 0 ]
	then
		gensrcs_net_ip
	else
		gensrcs_net_ip \
			+test.ha
	fi
	gen_ssa net::ip bytes io strconv strings strio fmt
}

net_unix() {
	printf '# net::unix\n'
	gen_srcs net::unix \
		addr.ha \
		'$(PLATFORM).ha'
	gen_ssa net::unix strings
}

math_random() {
	gen_srcs math::random \
		random.ha
	gen_ssa math::random
}

os() {
	gen_srcs os \
		'$(PLATFORM)/environ.ha' \
		'$(PLATFORM)/exit.ha' \
		'$(PLATFORM)/dirfdfs.ha' \
		'$(PLATFORM)/fdstream.ha' \
		'$(PLATFORM)/open.ha' \
		'$(PLATFORM)/stdfd.ha' \
		'$(PLATFORM)/fs.ha' \
		stdfd.ha \
		fs.ha
	gen_ssa os io strings types fs encoding::utf8 bytes bufio errors
}

os_exec() {
	gen_srcs os::exec \
		'$(PLATFORM).ha' \
		'exec$(PLATFORM).ha' \
		'process$(PLATFORM).ha' \
		types.ha \
		cmd.ha
	gen_ssa os::exec os strings fmt bytes path errors
}

path() {
	gen_srcs path \
		'$(PLATFORM).ha' \
		util.ha \
		join.ha \
		names.ha \
		iter.ha
	gen_ssa path strings bufio bytes
}

gensrcs_strconv() {
	gen_srcs strconv \
		types.ha \
		itos.ha \
		utos.ha \
		stou.ha \
		stoi.ha \
		numeric.ha \
		ftos.ha \
		$*
}

slice() {
	gen_srcs slice \
		reverse.ha \
		void.ha
	gen_ssa slice types
}

gensrcs_sort() {
	gen_srcs sort \
		search.ha \
		sort.ha \
		$*
}

sort() {
	if [ $testing -eq 0 ]
	then
		gensrcs_sort
	else
		gensrcs_sort \
			+test.ha
	fi
	gen_ssa sort
}

strconv() {
	if [ $testing -eq 0 ]
	then
		gensrcs_strconv
	else
		gensrcs_strconv \
			+test/stou.ha \
			+test/stoi.ha
	fi
	gen_ssa strconv types strings ascii
}

strings() {
	gen_srcs strings \
		concat.ha \
		contains.ha \
		cstrings.ha \
		dup.ha \
		iter.ha \
		sub.ha \
		suffix.ha \
		tokenize.ha \
		utf8.ha \
		index.ha
	gen_ssa strings bytes encoding::utf8 types
}

strio() {
	gen_srcs strio \
		dynamic.ha \
		fixed.ha \
		ops.ha
	gen_ssa strio io strings encoding::utf8 errors
}

time() {
	gen_srcs time \
		'$(PLATFORM)/functions.ha' \
		'$(PLATFORM)/$(ARCH).ha' \
		types.ha
	gen_ssa time linux::vdso
}

temp() {
	gen_srcs temp \
		'$(PLATFORM).ha'
	gen_ssa temp crypto::random encoding::hex fs io os path strio
}

types() {
	gen_srcs types \
		limits.ha \
		classes.ha \
		'arch$(ARCH).ha'
	gen_ssa types
}

unicode() {
	gen_srcs unicode \
		properties.ha \
		unicode.ha
	gen_ssa unicode
}

unix() {
	# XXX: getuid and setuid are probably platform-specific too
	gen_srcs unix \
		nice'$(PLATFORM)'.ha \
		getuid.ha \
		setuid.ha
	gen_ssa unix errors
}

unix_passwd() {
	gen_srcs unix::passwd \
		passwd.ha
	gen_ssa unix::passwd bufio io os strconv strings
}

uuid() {
	gen_srcs uuid \
		uuid.ha
	gen_ssa uuid crypto::random strio fmt endian io bytes
}

printf '# This file is generated by the gen-stdlib script, do not edit it by hand\n\n'

modules="ascii
bufio
bytes
compress_flate
compress_zlib
crypto_math
crypto_random
crypto_md5
crypto_sha1
crypto_sha256
crypto_sha512
dirs
encoding_hex
encoding_utf8
encoding_xml
endian
errors
fmt
format_elf
fs
getopt
hare_ast
hare_lex
hare_module
hare_parse
hare_unparse
hash
hash_adler32
hash_fnv
io
linux
linux_vdso
net
net_ip
net_unix
math_random
os
os_exec
path
slice
sort
strconv
strings
strio
temp
time
types
unicode
unix
unix_passwd
uuid"
stdlib() {
	rt
	for module in $modules; do
		gen_lib "$(printf "%s" "$module" | tr -s '_' '::')"
	done
	for module in $modules; do
		"$module"
	done
}

genrules
genrules test
